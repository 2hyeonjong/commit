# 배열에서 특정 값을 찾는 방법


# 파이썬이 느린이유
## 1. 파이썬은 정적이 아닌 동적 타입이다.
이것은 프로그램 실행 시, 인터프리터는 정의된 변수의 유형을 알고 있지 않다는 것을 의미
C언어 변수의 경우, 컴파일러는 단지 그 정의만으로도 변수의 유형을 알고 있다. 파이썬 변수의 경우는
파이썬 개체의 일부 종류
```C
int a =1;
int b =2;
int c = a+b;
```
C 컴파일러는 시작할 때부터 a와 b는 정수형이라는 것을 알고 있지만, 단순한 어떤것도 할 수 없다.
정수형을 아는 것으로는 메모리 상의 단순한 값에 두 개의 정수를 더하고, 이를 다른 정수로 변환하는 루틴을
호출할 수 있다. 개략적인 도식으로 나타내면 이벤트의 순서는 다음과 같다.
### C 덧셈
1. <int> 1을 a에 할당  
2. <int> 2을 b에 할당  
3. binary_add<int, int>(a,b) 호출  
4. 결과를 c에 할당    
  
파이썬에서의 같은 역할의 코드는 아래와 같다.
```python
a = 1
b = 2
c = a+b
```
인터프리터는 1과 2는 개체라는 것만 알지, 그것들의 타입은 알지 못한다. 그래서 인터프리터는 타입 정보를 찾기 위해
각 변수의 PyObject_HEAD을 검사한 후, 두 타입의 적절한 덧셈 루틴을 호출해야 한다. 마지막으로 반환 값을 보관 유지
하는 새로운 Python 개체를 만들고 초기화 해야한다.  
  
이벤트의 순서는 대략 다음과 같다.
###파이썬 덧셈
1. a에 1을 할당  
1a. a->PyObject_HEAD->typecode 정수 설정  
1b. a->val = 1 설정  
2. b에 2를 할당  
2a. b->PyObject_HEAD->typecode 정수 설정  
2b. b->val = 2 설정  
3. binary_add(a,b) 호출  
3a. a->PyObject_HEAD 에서 typecode 찾기  
3b. a는 정수형; 값 a->val  
3c. b->PyObject_HEAD 에서 typecode 찾기  
3d. b는 정수형; 값 b->val  
3e. binary_add<int, int>(a->val, b->val) 호출  
3f. 정수형 결과값 result  
4. 파이썬 개체 c 생성  
4a. c->PyObject_HEAD->typecode 정수 설정  
4b. c->val에 result 설정  

동적 타이핑은 모든 작업에 더 많은 단계가 있다는 것은 의미한다. 이것이 숫자데이터에 관한 연산에서 C언어와 비교했을 떄,
파이썬이 느린 가장 큰 이유이다.

## 2. 파이썬은 컴파일 형식이 아닌 인터프리터 형식이다.
위에서 인터프리터와 컴파일된 코드 사이의 차이점을 보았다. 스마트한 컴파일러는 결과의 속도를 높일 수 있도록, 반복되거나
불필요한 연산을 미리 내다보고 최적화할 수 있다. 컴파일러 최적화는 컴파일러만의 특성이다.

## 3. 파이썬의 개체모델은 비효율적인 메모리 엑세스가 발생할 수 있다.
<설명 필요>

# 파이썬을 사용하는 이유?
1. 사용하기 쉽다.
2. 개발시간의 효율적인 사용
3. 파이썬을 통해 쉽게 컴파일된 라이브러리에 접근


# hash table


읽어본 논문(머신러닝에 대해)
resnet, inception등 모델 직접 구현해보기
object tracking 모듈 중 어떤 모듈 사용?
